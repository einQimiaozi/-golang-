## 结构

![jiegou](https://img.draveness.me/2020-10-18-16030322432679/hmap-and-buckets.png)

1.count:表中元素总数量

2.B：桶数量，由于hashmap的桶数量一定是2^n，所以B代表的是n，而不是实际的桶数量

3.hash0：用于初始化hash函数的随机种子，作用是增加hash函数的随机性，减少hash碰撞

4.oldbuckets：指向老桶数组的指针(即扩容前的老桶)

5.buckets：指向当前桶数组的指针

每个map里保存了多个bmap，bmap就是hash桶，bmap的大小为8,桶内元素如果超过8个并且发生hash碰撞，则会使用extra指向的溢出桶保存溢出的元素

至于每个bmap和溢出桶之间的对应关系，由bmap中的overflow指针维护，该指针指向当前bmap对应的溢出桶

##  初始化

1. 计算哈希占用的内存是否溢出或者超出能分配的最大值

2.调用 runtime.fastrand 获取一个随机的哈希种子hash0

3.计算出需要的最小需要的桶的数量，如果桶数量小于2^4,则直接创建2^n个桶，如果大于2^4个，则除了创建需要的2^n个桶外，还会创建2^n-4个溢出桶,这里的n就是结构部分提到的B成员变量

4.使用 runtime.makeBucketArray 创建用于保存桶的数组，桶在内存中是一片连续空间，和数组一样

## hash比较

bmap中存储了tophash参数，该参数是该桶代表的hash值的高8位

通过比较一个key的hash值的高8位来判断该key所属的bmap

访问时先通过上述方法确认待查key的所属，后通过比较bmap中每个值和key的剩余低位来加速判断是否一致完成元素访问

## 扩容

1.装载因子：默认为6.5,和java中的区别在于，golang的装载因子=桶中元素/桶数量，所以一般因子会大于1,而java中取的是比例，所以会小于1

2.首先会判断当前桶是否处在扩容状态，如果在则不执行扩容

3.扩容又分等量扩容和翻倍扩容
  - 等量扩容：当溢出桶过多时会引发性能下降(溢出桶一般都分配不满，或者bmap中又元素被删除，此时bmap不满但是bmap指向的溢出桶又有数据，所以会有内存泄漏)，此时执行等量扩容，buckets大小=oldbuckets大小，也就是将溢出桶和bmap中的所有数据都集中到bmap里，清理内存碎片同时加快元素访问速度，这一步会new一个新的bmap然后将溢出桶和旧bmap的元素拷贝过去再执行Gc
  - 触发等量扩容的条件：B<=15，已使用的溢出桶个数>=2的B次方时，引发等量扩容。B>15，已使用的溢出桶个数>=2的15次方时，引发等量扩容。
  - 翻倍扩容：每次扩容B+1大小，扩容时和等量扩容一样通过new新的bmap进行拷贝，注意翻倍扩容会处罚分流，因为一个元素再扩容后可能在原来旧桶的位置，也可能会在旧桶+旧桶长度的位置(这个和java的hashmap一样)

## 其他

1.map线程不安全，在同一时间段内，让不同 goroutine 中的代码，对同一个字典进行读写操作是不安全的。字典值本身可能会因这些操作而产生混乱，相关的程序也可能会因此发生不可预知的问题。


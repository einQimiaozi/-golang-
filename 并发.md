## select关键字

select配合多个channel使用，语法和switch一样，可以设置default，只不过分支只能对channel进行监控

```golang
// 实现对ch1和ch2的多路复用监控
for {
		select {
		case <-ch1:
			println("case1")
		case <-ch2:
			println("case2")
		}
	}
```

select中的多个case如果都满足要求，那么会随机执行，防止第一个case一直满足要求的情况下后续的case无法执行

## context

context是golang中用于传递当前控制状态的一种机制

你可以理解为：我们希望多个线程被同一个开关操作，但是这些线程又会fork自己的子线程，数量不定，此时我们不论使用select还是channel都不方便控制，使用context就是一个很好的方法

context的使用就像一个树一样，如果在主线程里创建一个context，那么它会记录当前主线程中你要保留的上下文状态，任何可以访问该context变量的方法都可以监控该状态，该context会随这线程的深入变成一颗context树

Context.Background():该方法会创建一个空的context，作为当前方法的一个根context

使用案例

```golang

var key string = "name"

func main() {
  // 创建一个空的context，之后创建其子节点cancel，返回一个context实例和一个cancel方法，cancel方法用于取消
  // 可以理解为一个开关，调用cancel方法=关闭开关，ctx=开关本身
	ctx, cancel := context.WithCancel(context.Background())
	// 附加值，所有获取该context的方法都可以获取 “监控1“ 这个值
	valueCtx := context.WithValue(ctx, key, "监控1")
	go watch(valueCtx)
	time.Sleep(10 * time.Second)
	fmt.Println("可以了，通知监控停止")
  // 执行取消函数，此时可以从ctx.Done()中取出值了
	cancel()
	//为了检测监控过是否停止，如果没有监控输出，就表示停止了
	time.Sleep(5 * time.Second)
}

func watch(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
		//取出值
			fmt.Println(ctx.Value(key), "监控退出，停止了...")
			return
		default:
		//取出值
			fmt.Println(ctx.Value(key), "goroutine监控中...")
			time.Sleep(2 * time.Second)
		}
	}
}
```

执行结果

```
【监控1】 goroutine监控中...
【监控1】 goroutine监控中...
【监控1】 goroutine监控中...
【监控1】 goroutine监控中...
【监控1】 goroutine监控中...
【监控1】 goroutine监控中...
可以了，通知监控停止
【监控1】 监控退出，停止了...
```

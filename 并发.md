## select关键字

select配合多个channel使用，语法和switch一样，可以设置default，只不过分支只能对channel进行监控

```golang
// 实现对ch1和ch2的多路复用监控
for {
		select {
		case <-ch1:
			println("case1")
		case <-ch2:
			println("case2")
		}
	}
```

select中的多个case如果都满足要求，那么会随机执行，防止第一个case一直满足要求的情况下后续的case无法执行

## context

context是golang中用于传递当前控制状态的一种机制

你可以理解为：我们希望多个线程被同一个开关操作，但是这些线程又会fork自己的子线程，数量不定，此时我们不论使用select还是channel都不方便控制，使用context就是一个很好的方法

context的使用就像一个树一样，如果在主线程里创建一个context，那么它会记录当前主线程中你要保留的上下文状态，任何可以访问该context变量的方法都可以监控该状态，该context会随这线程的深入变成一颗context树

Context.Background():该方法会创建一个空的context，作为当前方法的一个根context

使用案例

```golang

var key string = "name"

func main() {
  // 创建一个空的context，之后创建其子节点cancel，返回一个context实例和一个cancel方法，cancel方法用于取消
  // 可以理解为一个开关，调用cancel方法=关闭开关，ctx=开关本身
	ctx, cancel := context.WithCancel(context.Background())
	// 附加值，所有获取该context的方法都可以获取 “监控1“ 这个值
	valueCtx := context.WithValue(ctx, key, "监控1")
	go watch(valueCtx)
	time.Sleep(10 * time.Second)
	fmt.Println("可以了，通知监控停止")
  // 执行取消函数，此时可以从ctx.Done()中取出值了
	cancel()
	//为了检测监控过是否停止，如果没有监控输出，就表示停止了
	time.Sleep(5 * time.Second)
}

func watch(ctx context.Context) {
	for {
		select {
		case <-ctx.Done():
		//取出值
			fmt.Println(ctx.Value(key), "监控退出，停止了...")
			return
		default:
		//取出值
			fmt.Println(ctx.Value(key), "goroutine监控中...")
			time.Sleep(2 * time.Second)
		}
	}
}
```

执行结果

```
【监控1】 goroutine监控中...
【监控1】 goroutine监控中...
【监控1】 goroutine监控中...
【监控1】 goroutine监控中...
【监控1】 goroutine监控中...
【监控1】 goroutine监控中...
可以了，通知监控停止
【监控1】 监控退出，停止了...
```

## channel

1.缓冲

channel分为有缓冲和无缓冲两种，即

```golang
ch1 := make(chan int) // 无缓冲channel中的数据必须立刻存取，连续两次向channel中读写数据会阻塞掉第二次
ch2 := make(chan int,10) // 有缓冲的channel，当channel内的数据为10个之后，该channel的性质就和无缓冲的一样了，直到channel中的数据被取出
```

2.channel实现原理

```golang
// path:src/runtime/chan.go
// channel的结构
type hchan struct {
  qcount uint          // 当前队列列中剩余元素个数
  dataqsiz uint        // 环形队列长度，即可以存放的元素个数
  buf unsafe.Pointer   // 环形队列列指针
  elemsize uint16      // 每个元素的⼤⼩
  closed uint32        // 标识关闭状态
  elemtype *_type      // 元素类型
  sendx uint           // 队列下标，指示元素写⼊入时存放到队列列中的位置 x
  recvx uint           // 队列下标，指示元素从队列列的该位置读出  
  recvq waitq          // 等待读消息的goroutine队列
  sendq  waitq         // 等待写消息的goroutine队列
  lock mutex           // 互斥锁，chan不允许并发读写
} 
```


重要参数
  - dataqsiz：指向队列的长度为6，即可缓存6个元素
  - buf：指向队列的内存，队列中还剩余两个元素
  - qcount：当前队列中剩余的元素个数
  - sendx：指后续写入元素的位置
  - recvx：指从该位置读取数据

注意，一般情况下recvq和sendq至少有一个为空。只有一个例外，那就是同一个goroutine使用select语句向channel一边写数据一边读数据。

发送：
  - 如果recvq队列不为空，说明buf没有数据或者没有buf，此时直接从recvq等待队列中取出一个G，并把数据写入，最后把该G唤醒，结束发送过程(G可以理解为一个channel的基本单位)
  - 如果buf有空余位置，则把数据写入buf中，结束发送过程；
  - 如果buf没有空余位置，则把数据写入G，将当前G写入sendq队列，进入休眠，等待被读goroutine唤醒；

接收
  - 如果等待发送队列sendq不为空，且没有buf，直接从sendq队列中取出G读取，唤醒G，结束
  - 如果等待发送队列sendq不为空，说明buf已满，从buf队列中首部读取数据，然后从sendq等待发送队列中取出G写入缓冲区尾部，结束
  - 如果sendq为空且buf中有数据，则从buf取出数据，结束读取过程

注意点：
  - 向已经关闭的channel中写入数据会发生Panic
  - 关闭已经关闭的channel会发生Panic
  - 关闭值为nil的channel会发生Panic
  - channel不允许并发同时读写

## sync(锁)

### Mutex(互斥锁)

1.结构

```golang
type Mutex struct {
	state int32    // 锁状态，32位，0位=是否上锁 1位=是否处于唤醒状态 2位=是否处于饥饿模式 3-31位=等待当前锁的协程的数量
	sema  uint32   // 控制锁状态的信号量
}
```

2.互斥锁分为正常模式与饥饿模式
  - 正常模式：协程获取锁按照非公平模式获取，效率高，但是由于新启动的协程一般还在cpu上执行，所以相比与之前竞争失败而刚被唤醒的协程在速度上有优势，所以有可能造成某些协程饿死
  - 饥饿模式：协程获取锁按照公平模式获取，一个协程在正常模式下如果超过1ms没有获取到锁那么锁就会转为饥饿模式，主要是为了防止被唤醒的协程饿死，锁会直接交给等待队列最前面的协程，其他协程不会自旋，只会在原地等待(因为饥饿模式是由上一个持有锁的协程执行unlock方法主动将锁交给下一个协程，所以不需要自旋，减少cpu空转)
  - 饥饿模式退出条件：等待队列队尾获取锁(也就是等待队列被清空了，所有任务执行完了)

3.加锁实现原理：
  - 无锁状态下直接使用cas获取，一般都是锁第一次被初始化时，否则向下走
  - 如果有锁并且当前硬件支持自旋，锁不处于饥饿模式，尝试自旋4次获取锁
  - 如果还没获取成功，则当前协程被休眠并不断尝试被sema唤醒
  - 被唤醒后：
    - 正常模式：重置自旋次数后回到自旋前状态，重新尝试获取锁
    - 饥饿模式：直接获取锁并判断是否可以退出饥饿模式

## RWMutex(读写锁)

1.结构

```golang
type RWMutex struct {
	w           Mutex // 锁本身
	writerSem   uint32 // 写操作
	readerSem   uint32 // 读操作
	readerCount int32 // 读协程数量
	readerWait  int32 // 等待写的协程数量
}
```

2.读：每次将readerCount+1即可，如果readerCount为负数，则代表当前某个协程正在写，则读操作阻塞并等待写操作释放锁(由writerSem==0触发)

3.写：如果readerCount为0则执行写操作同时将readerCount置为负，否则阻塞并等待readercount为0(由readerSem==0触发)

## waitGroup

waitGroup用于使线程等待其他协程执行完毕

waitGroup.Add()每次+1,waitGroup.Done()每次-1,线程通过waitGroup.Wait()方法阻塞，当waitGroup为0时当前线程才可以被唤醒继续执行，并且该方法在执行结束前同一线程内不能再次执行，Add方法可以传入任意负数直接将waitGroup()归0结束等待

## sync.Once

1.结构

```golang
type Once struct {
	done uint32
	m    Mutex
}
```

2.作用：sync.Once只有一个对外方法Do(func) 该方法传入一个func，保证func在该线程中只被执行一次

3.原理：
 - Do方法会判断dones==0,如果为true则执行func，否则直接返回
 - 当func第一次被执行时，Do方法会加锁将done+1并执行func

## sync.Cond

Cond就是条件变量，初始化一个Cond我们需要传入一把锁

```golang
c := sync.NewCond(&sync.Mutex{})
```

通过cond的wait方法可以让调用该方法的协程被放入一个条件队列里并阻塞，signal方法可以每次唤醒该队列中的第一个

cond的作用是为了防止某个协程执行任务但长时间无法满足条件时引起的cpu空转，如果出现这种情况可以使用cond.wait()阻塞该协程，当条件满足时用其他线程将其唤醒

Broadcast()方法可以唤醒条件队列中的全部协程，但要注意惊群，signal方法唤醒一个协程，顺序唤醒，先来先醒








